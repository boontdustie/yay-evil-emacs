#+BEGIN_SRC emacs-lisp
  (straight-use-package 'use-package)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :straight t
    :preface
    (setq frame-title-format '("Hack The Planet"))
    (defvar ian/indent-width 4) ;   :diminish eldoc-mode
    :config
    (setq eldoc-idle-delay 0.4))
#+END_SRC

** Indentation improvement
For Java and C/C++, change the formatting style from GNU (the default)
to the more standard K&R. Here we also set the indentation width of C,
C++, Java, and Python to the preferred value defined in
~ian/indent-width~ (all languages default to 4, except JavaScript,
which is 2, as controlled in ~web-mode~). Of course, you can change
the value depending on the language as well.
#+BEGIN_SRC emacs-lisp
  ;; Python (both v2 and v3)
  (use-package python
    :straight t
    :config (setq python-indent-offset ian/indent-width))
#+END_SRC

** Mouse wheel (track-pad) scroll speed
By default, the scrolling is way too fast to be precise and helpful,
let's tune it down a little bit.
#+BEGIN_SRC emacs-lisp
;;  (use-package mwheel
;;    :straight t
;;    :config (setq mouse-wheel-scroll-amount '(2 ((shift) . 1))
;;                  mouse-wheel-progressive-speed nil))
#+END_SRC

** Show matching parentheses
Reduce the highlight delay to instantly.
#+BEGIN_SRC emacs-lisp
  (use-package paren
    :straight t
    :init (setq show-paren-delay 0)
    :config (show-paren-mode +1))
#+END_SRC
** Setting up some frame defaults
Maximize the frame by default on start-up. Set the font to size 12.
#+BEGIN_SRC emacs-lisp

 (setq initial-frame-alist '((fullscreen . maximized)))
  ;;  (use-package frame
  ;;    :straight t
  ;;    :preface
  ;;    (defun ian/set-default-font ()
  ;;      (interactive)
  ;;      (when (member "Consolas" (font-family-list))
  ;;        (set-face-attribute 'default nil :family "Consolas"))
  ;;      (set-face-attribute 'default nil
  ;;                          :height 120
  ;;                         :weight 'normal))
  ;;    :config
  ;;    (ian/set-default-font))
#+END_SRC
** Ediff tweaks
Enter ediff with side-by-side buffers to better compare the
differences.
#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :straight t
    :config
    (setq ediff-window-setup-function #'ediff-setup-windows-plain)
    (setq ediff-split-window-function #'split-window-horizontally))
#+END_SRC
** Auto-pairing quotes and parentheses etc.
Electric-pair-mode has improved quite a bit in recent Emacs
versions. No longer need an extra package for this. It also takes care
of the new-line-and-push-brace feature.
#+BEGIN_SRC emacs-lisp
  (use-package elec-pair
    :straight t
    :hook (prog-mode . electric-pair-mode))
#+END_SRC
** Clean up whitespace on save
#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :hook (before-save . whitespace-cleanup))
#+END_SRC
** Dired tweaks
Delete intermediate buffers when navigating through dired.
#+begin_src emacs-lisp
;;  (use-package dired
;;    :straight t
;;    :config
;;    (setq delete-by-moving-to-trash t)
;;    (eval-after-load "dired"
;;      #'(lambda ()
;;          (put 'dired-find-alternate-file 'disabled nil)
;;          (define-key dired-mode-map (kbd "RET") #'dired-find-alternate-file))))
#+end_src

#+END_SRC
* Third-party packages
Many Emacsers love having tons of packages -- and that's absolutely
fine! However, one of the goals of the Yay-Evil distro is to provide
an essential-only foundation for users to build upon. Therefore, only
the most important packages and/or lightweight improvements will be
included here. For example, completion frameworks like Ivy or Helm are
considered heavy by many, yet the built-in Ido serves almost the same
purpose. The only arguably opinionated package is probably Evil, but
you probably saw that coming from the distro name, didn't you ;) ? If
you prefer the default keybindings, simply disable the section that
controls the Evil behaviors.

Normally, we need to add ~:ensure t~ to tell ~use-package~ to download packages when it's not available. But since we've added ~use-package-always-ensure~ in ~init.el~, we can omit it.
** GUI enhancements
*** Load custom theme
#+BEGIN_SRC emacs-lisp
    ;;(add-to-list 'custom-theme-load-path (concat user-emacs-directory "themes/"))
    ;;(load-theme 'twilight t) ; an orginal theme created by me.
  (use-package autothemer :ensure t)

  (straight-use-package
   '(rose-pine-emacs
     :host github
     :repo "thongpv87/rose-pine-emacs"
     :branch "master"))
  (load-theme 'rose-pine-moon t)
#+END_SRC

*** Dashboard welcome page
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :straight t
    :config
    (dashboard-setup-startup-hook)
    (setq dashboard-startup-banner 'logo
	  dashboard-banner-logo-title "The Truth Is Out There"
	  dashboard-items nil
	  dashboard-set-footer nil))
#+END_SRC
*** Syntax highlighting
Lightweight syntax highlighting improvement for numbers and escape
sequences (e.g. ~\n, \t~).
#+BEGIN_SRC emacs-lisp
  (use-package highlight-numbers
    :straight t
    :hook (prog-mode . highlight-numbers-mode))

  (use-package highlight-escape-sequences
    :straight t
    :hook (prog-mode . hes-mode))
#+END_SRC

** Vi keybindings

I personally find Vi(m) bindings to be the most efficient way of
editing text (especially code). I also changed the default ~:q~ and
~:wq~ to be killing current buffer, instead of killing the frame or
subsequently killing Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :straight t
    :diminish undo-tree-mode
    :init
    (setq evil-want-C-u-scroll t
	  evil-want-keybinding nil
	  evil-shift-width ian/indent-width)
    :hook (after-init . evil-mode)
    :preface
    (defun ian/save-and-kill-this-buffer ()
      (interactive)
      (save-buffer)
      (kill-this-buffer))
    :config
    (with-eval-after-load 'evil-maps ; avoid conflict with company tooltip selection
      (define-key evil-insert-state-map (kbd "C-n") nil)
      (define-key evil-insert-state-map (kbd "C-p") nil))
    (evil-ex-define-cmd "q" #'kill-this-buffer)
    (evil-ex-define-cmd "wq" #'ian/save-and-kill-this-buffer)
    (evil-define-key 'normal org-mode-map (kbd "TAB") #'org-cycle)
    (evil-define-key 'normal org-mode-map (kbd "<") #'org-do-promote)
    (evil-define-key 'normal org-mode-map (kbd ">") #'org-do-demote)
    (evil-define-key 'normal org-mode-map (kbd "M-<") #'org-promote-subtree)
    (evil-define-key 'normal org-mode-map (kbd "M->") #'org-demote-subtree)
    (evil-define-key 'normal org-mode-map (kbd "M-S-UP") #'org-move-subtree-up)
    (evil-define-key 'normal org-mode-map (kbd "M-S-DOWN") #'org-move-subtree-down))

  (setq-default evil-escape-delay 0.2)

#+END_SRC

Evil-leader
#+BEGIN_SRC emacs-lisp
  (use-package evil-leader
    :straight t
    :after evil)

  (global-evil-leader-mode)
  (evil-leader/set-key
     "e" 'find-file
     "b" 'switch-to-buffer
     "k" 'kill-buffer
     "l" 'load-file
     "c" 'string-rectangle
     "/" 'comment-or-uncomment-region
     "s" 'ag-project
     "r" 'helm-resume
     "i" 'ivy-resume)

    (evil-leader/set-leader ",")
#+END_SRC

  Evil-collection covers more parts of Emacs that the original Evil
  doesn't support (e.g. Packages buffer, eshell, calendar etc.)
  #+BEGIN_SRC emacs-lisp
    (use-package evil-collection
      :straight t
      :after evil
      :config
      (setq evil-collection-company-use-tng nil)
      (evil-collection-init))
#+END_SRC
Emulates tpope's vim commentary package (Use ~gcc~ to comment out a line,
~gc~ to comment out the target of a motion (for example, ~gcap~ to
comment out a paragraph), ~gc~ in visual mode to comment out the
selection etc.)
#+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :straight t
    :after evil
    :diminish
    :config (evil-commentary-mode +1))
#+END_SRC
** Git Integration
Tell magit to automatically put us in vi-insert-mode when committing a change.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :straight t
    :bind ("C-x g" . magit-status)
    :config (add-hook 'with-editor-mode-hook #'evil-insert-state))
#+END_SRC
** Searching/sorting enhancements & project management
*** Ido, ido-vertical, ido-ubiquitous and fuzzy matching
Selecting buffers/files with great efficiency. In my opinion, Ido is
enough to replace Ivy/Counsel and Helm. We install ido-vertical to get
a better view of the available options (use ~C-n~, ~C-p~ or arrow keys
to navigate). Ido-ubiquitous (from the ~ido-completing-read+~ package)
provides us ido-like completions in describing functions and variables
etc. Fuzzy matching is a nice feature and we have flx-ido for that
purpose.
#+BEGIN_SRC emacs-lisp
    (use-package ido
      :straight t
      :config
      (ido-mode +1)
      (setq ido-everywhere t
	    ido-enable-flex-matching t))

    (use-package ido-vertical-mode
      :straight t
      :config
      (ido-vertical-mode +1)
      (setq ido-vertical-define-keys 'C-n-C-p-up-and-down))

    (use-package ido-completing-read+ :config (ido-ubiquitous-mode +1))

    (use-package flx-ido
      :straight t
      :config (flx-ido-mode +1))
#+END_SRC
** Programming language support and utilities
*** Company for auto-completion
Use ~C-n~ and ~C-p~ to navigate the tooltip.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :straight t
    :diminish company-mode
    :hook (prog-mode . company-mode)
    :config
    (setq company-minimum-prefix-length 1
	  company-idle-delay 0.1
	  company-selection-wrap-around t
	  company-tooltip-align-annotations t
	  company-frontends '(company-pseudo-tooltip-frontend ; show tooltip even for single candidate
			      company-echo-metadata-frontend))
    (define-key company-active-map (kbd "C-n") 'company-select-next)
    (define-key company-active-map (kbd "C-p") 'company-select-previous))
#+END_SRC
*** Flycheck
A modern on-the-fly syntax checking extension -- absolute essential
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :straight t
    :config (global-flycheck-mode +1))
#+END_SRC

*** Org Mode
Some minimal org mode tweaks: org-bullets gives our headings (h1, h2,
h3...) a more visually pleasing look.

#+BEGIN_SRC emacs-lisp
    (use-package org
      :straight t
      :hook ((org-mode . visual-line-mode)))

    (use-package org-bullets
      :straight t
      :hook (org-mode . org-bullets-mode))
#+END_SRC

*** Useful major modes
Markdown mode and Web mode, the latter covers our usages of HTML/CSS/JS/JSX/TS/TSX/JSON.
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :straight t
    :hook (markdown-mode . visual-line-mode))

  (use-package web-mode
    :straight t
    :mode (("\\.html?\\'" . web-mode)
	   ("\\.css\\'"   . web-mode)
	   ("\\.jsx?\\'"  . web-mode)
	   ("\\.tsx?\\'"  . web-mode)
	   ("\\.json\\'"  . web-mode))
    :config
    (setq web-mode-markup-indent-offset 2) ; HTML
    (setq web-mode-css-indent-offset 2)    ; CSS
    (setq web-mode-code-indent-offset 2)   ; JS/JSX/TS/TSX
    (setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'"))))
#+END_SRC
** Miscellaneous
*** Diminish minor modes
The diminish package is used to hide unimportant minor modes in the
modeline. It provides the ~:diminish~ keyword we've been using in
other use-package declarations.
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :straight t
    :demand t)
#+END_SRC
*** Which-key
Provides us with hints on available keystroke combinations.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :straight t
    :diminish which-key-mode
    :config
    (which-key-mode +1)
    (setq which-key-idle-delay 0.4
	  which-key-idle-secondary-delay 0.4))
#+END_SRC
*** Configure PATH on macOS
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :straight t
    :config (when (memq window-system '(mac ns x))
	      (exec-path-from-shell-initialize)))
#+END_SRC
* Essential GPK Customization
Global keys
#+begin_src emacs-lisp
(global-set-key (kbd "M-b") 'ido-switch-buffer) ;; switch between buffers
#+end_src

LSP Mode
#+begin_src emacs-lisp
  ;; (use-package lsp-mode
  ;;   :straight t
  ;;   :hook ((js-mode         ; ts-ls (tsserver wrapper)
  ;;        web-mode        ; ts-ls/HTML/CSS
  ;;        ruby-mode       ; ruby-server
  ;;        ) . lsp-deferred)
  ;;   :commands lsp
  ;;   :config
  ;;   (setq lsp-auto-guess-root t)
  ;;   (setq lsp-log-io nil)
  ;;   (setq lsp-restart 'auto-restart)
  ;;   (setq lsp-enable-symbol-highlighting nil)
  ;;   (setq lsp-enable-on-type-formatting nil)
  ;;   (setq lsp-signature-auto-activate nil)
  ;;   (setq lsp-signature-render-documentation nil)
  ;;   (setq lsp-eldoc-hook nil)
  ;;   (setq lsp-modeline-code-actions-enable nil)
  ;;   (setq lsp-modeline-diagnostics-enable nil)
  ;;   (setq lsp-headerline-breadcrumb-enable nil)
  ;;   (setq lsp-semantic-tokens-enable nil)
  ;;   (setq lsp-enable-folding nil)
  ;;   (setq lsp-enable-imenu nil)
  ;;   (setq lsp-enable-snippet nil)
  ;;   (setq read-process-output-max (* 1024 1024)) ;; 1MB
  ;;   (setq lsp-idle-delay 0.5))

  ;; (use-package lsp-ui
  ;;   :straight t
  ;;   :commands lsp-ui-mode
  ;;   :config
  ;;   (setq lsp-ui-doc-enable t)
  ;;   (setq lsp-ui-doc-header t)
  ;;   (setq lsp-ui-doc-include-signature t)
  ;;   (setq lsp-ui-doc-border (face-foreground 'default))
  ;;   (setq lsp-ui-sideline-show-code-actions t)
  ;;   (setq lsp-ui-sideline-delay 0.05)
  ;;   (setq lsp-ui-sideline-show-hover t)
  ;;   (setq lsp-ui-sideline-update-mode t)
  ;;   (setq lsp-ui-peek-enable t)
  ;;   (setq lsp-ui-peek-jump-backward t)
  ;;   (setq lsp-ui-peek-jump-forwardt t)
  ;;   (setq lsp-ui-peek-show-directory t))

  ;; ;; ;; ruby - lsp-mode
  ;; ;; ;; Set up before-save hooks to format buffer and add/dele te imports.
  ;; (defun
  ;;     lsp-ruby-install-save-hooks ()
  ;;   (add-hook 'before-save-hook #'lsp-format-buffer t t)
  ;;   (add-hook 'before-save-hook #'lsp-organize-imports t t))
  ;; (add-hook 'ruby-mode-hook #'lsp-ruby-install-save-hooks)

  ;; (add-hook 'ruby-mode-hook #'lsp)

 #+end_src


Rename file and buffer
 #+begin_src emacs-lisp
   ;; source: http://steve.yegge.googlepages.com/my-dot-emacs-file
   (defun rename-file-and-buffer (new-name)
     "Renames both current buffer and file it's visiting to NEW-NAME."
     (interactive "sNew name: ")
     (let ((name (buffer-name))
	   (filename (buffer-file-name)))
       (if (not filename)
	   (message "Buffer '%s' is not visiting a file!" name)
	 (if (get-buffer new-name)
	     (message "A buffer named '%s' already exists!" new-name)
	   (progn
	     (rename-file name new-name 1)
	     (rename-buffer new-name)
	     (set-visited-file-name new-name)
	     (set-buffer-modified-p nil))))))


   (global-set-key (kbd "C-c R") 'rename-file-and-buffer)
 #+end_src

 Projectile
 #+begin_src emacs-lisp
   (use-package projectile
     :straight t
     :config
     (setq projectile-completion-system 'ido))

   (projectile-global-mode)
 #+end_src


 # Custom formatter to specify using StandardRB
 #+begin_src emacs-lisp
     (use-package format-all :straight t)
     (add-hook 'prog-mode-hook 'format-all-mode)

     (defun fmt-ruby-save-hooks ()
       (add-hook 'before-save-hook #'format-all-buffer t))
     (add-hook 'ruby-mode-hook #'fmt-ruby-save-hooks)

 #+end_src

 # Custom formatter to specify using StandardRB
 #+begin_src emacs-lisp
       (use-package real-auto-save
	  :straight t)
	 (add-hook 'org-mode-hook 'real-auto-save-mode)
       (setq real-auto-save-interval 1) ;; in seconds

 #+end_src

 Elfeed
 #+begin_src emacs-lisp
      (use-package elfeed
	  :straight t)

      (global-set-key (kbd "C-x w") 'elfeed)

      (add-hook 'elfeed-show-mode-hook (lambda () (setq-local show-trailing-whitespace nil)))
 #+end_src

 # Load elfeed-org

 #+begin_src emacs-lisp
	 (use-package elfeed-org
	   :straight t)

	 ;; Initialize elfeed-org
	 ;; This hooks up elfeed-org to read the configuration when elfeed
	 ;; is started with =M-x elfeed=
	 (elfeed-org)

	 ;; Optionally specify a number of files containing elfeed
	 ;; configuration. If not set then the location below is used.
	 ;; Note: The customize interface is also supported.
	 (setq rmh-elfeed-org-files (list "~/.emacs.d/elfeed/elfeed.org"))
 #+end_src

 #+begin_src emacs-lisp
  (straight-use-package
   '(liquid-mode
     :host github
     :repo "boontdustie/liquid-mode"
     :branch "master"))
 #+end_src

 #+begin_src emacs-lisp
   (set-language-environment "UTF-8")
   (set-default-coding-systems 'utf-8)
   (setq default-fill-column 80)
   (setq delete-old-versions -1 )		; delete excess backup versions silently
   (setq version-control t )		; use version control
   (setq vc-make-backup-files t )		; make backups file even when in version controlled dir
   (setq make-backup-files nil) ; stop creating ~ files
   (setq vc-follow-symlinks t )                                   ; don't ask for confirmation when opening symlinked file
   (setq inhibit-startup-screen t )	; inhibit useless and old-school startup screen
   (setq ring-bell-function 'ignore )	; silent bell when you make a mistake
   (setq sentence-end-double-space nil)	; sentence SHOULD end with only a point.
   (setq default-fill-column 80)		; toggle wrapping text at the 80th character

 #+end_src

 #+begin_src emacs-lisp
   (use-package use-package-ensure-system-package
     :ensure t)
      (use-package ag
	     :ensure t
	     :ensure-system-package (ag . "wajig install ag"))

#+end_src

# Github copilot
# https://github.com/copilot-emacs/copilot.el
#+begin_src emacs-lisp
	(use-package copilot
	:straight (:host github :repo "copilot-emacs/copilot.el" :files ("*.el"))
	:ensure t)


	(add-hook 'prog-mode-hook 'copilot-mode)
	(define-key copilot-completion-map (kbd "<tab>") 'copilot-accept-completion)
	(define-key copilot-completion-map (kbd "TAB") 'copilot-accept-completion)

	(add-to-list 'copilot-major-mode-alist '("enh-ruby" . "ruby"))



      (defun rk/no-copilot-mode ()
	"Helper for `rk/no-copilot-modes'."
	(copilot-mode -1))

      (defvar rk/no-copilot-modes '(shell-mode
			      inferior-python-mode
			      eshell-mode
			      term-mode
			      vterm-mode
			      comint-mode
			      compilation-mode
			      debugger-mode
			      dired-mode-hook
			      compilation-mode-hook
			      flutter-mode-hook
			      minibuffer-mode-hook)
	"Modes in which copilot is inconvenient.")

      (defun rk/copilot-disable-predicate ()
	"When copilot should not automatically show completions."
	(or rk/copilot-manual-mode
	(member major-mode rk/no-copilot-modes)
	(company--active-p)))

      (add-to-list 'copilot-disable-predicates #'rk/copilot-disable-predicate)

    (defvar rk/copilot-manual-mode nil
      "When `t' will only show completions when manually triggered, e.g. via M-C-<return>.")

    (defun rk/copilot-change-activation ()
      "Switch between three activation modes:
    - automatic: copilot will automatically overlay completions
    - manual: you need to press a key (M-C-<return>) to trigger completions
    - off: copilot is completely disabled."
      (interactive)
      (if (and copilot-mode rk/copilot-manual-mode)
	(progn
	(message "deactivating copilot")
	(global-copilot-mode -1)
	(setq rk/copilot-manual-mode nil))
	(if copilot-mode
	(progn
	  (message "activating copilot manual mode")
	  (setq rk/copilot-manual-mode t))
	(message "activating copilot mode")
	(global-copilot-mode))))

    (define-key global-map (kbd "M-C-<escape>") #'rk/copilot-change-activation)

  (defun rk/copilot-complete-or-accept ()
    "Command that either triggers a completion or accepts one if one
  is available. Useful if you tend to hammer your keys like I do."
    (interactive)
    (if (copilot--overlay-visible)
	(progn
	(copilot-accept-completion)
	(open-line 1)
	(next-line))
      (copilot-complete)))

  (define-key copilot-mode-map (kbd "M-C-<next>") #'copilot-next-completion)
  (define-key copilot-mode-map (kbd "M-C-<prior>") #'copilot-previous-completion)
  (define-key copilot-mode-map (kbd "M-C-<right>") #'copilot-accept-completion-by-word)
  (define-key copilot-mode-map (kbd "M-C-<down>") #'copilot-accept-completion-by-line)
  (define-key global-map (kbd "M-C-<return>") #'rk/copilot-complete-or-accept)

(defun rk/copilot-quit ()
  "Run `copilot-clear-overlay' or `keyboard-quit'. If copilot is
cleared, make sure the overlay doesn't come back too soon."
  (interactive)
  (condition-case err
      (when copilot--overlay
	(lexical-let ((pre-copilot-disable-predicates copilot-disable-predicates))
	  (setq copilot-disable-predicates (list (lambda () t)))
	  (copilot-clear-overlay)
	  (run-with-idle-timer
	   1.0
	   nil
	   (lambda ()
	     (setq copilot-disable-predicates pre-copilot-disable-predicates)))))
    (error handler)))

(advice-add 'keyboard-quit :before #'rk/copilot-quit)

#+end_src
